\chapter{Introduction}

Tracking of programmers time happens to be an essential part of the job in the IT industry.
The reports provided by programmers are the basis for calculating a salary or even deciding
the future of an employee by the management. In my own experience it was hard to determine
which activities constituted billing time or if different activities should be treated
differently. Many times I did stumble upon hard to fix bugs or complicated issues solving
which took many trials and errors. Then by the end of it, I was happy for the issues to be
fixed, nevertheless it was hard for me to calculate the exact amount of billing hours it
took me and how to prove this reported effort to my employer.

It was then I came up with researching this area a bit further. My idea was to track
programmers activities even before they create any meaningful output. Of course, you
could argue that the paradigms of continuous integration already solve this problem,
however at the heart of my concerns lied the relatively high granularity of the data,
which would be practically unachievable just by utilizing common paradigms (you do not
imagine a programmer committing her/his work to git every minute or even more frequently
without a high nosedive of her/his productivity).

The thesis contains 5 chapters and appendices.
In the chapter \ref{r:background} we study related works.

% Probably mention Leinonen et. al., write that he received awards and he's well regarded for his outstanding research in analysing the process of writing code of students

% Say what it is about and what not. Say what data you use and which not. Say what to expect.

% Say that by activities you mostly mean just keystrokes.
