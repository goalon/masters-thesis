% TODO reconsider wording and structure
\section{Tools for visualizing the programming process}

% Mention literature review
% TODO How it can be done - different means like SCSs etc.
Visualization of software is a vigorously studied area. \cite{Mat16SoftwareVisualizationReview} It concerns mainly representations of software structure, behavior and evolution \cite{DieSoftViz}. In my thesis I am mostly interested in the last point with emphasis on visualization of the programming process by analyzing keystrokes. The different takes on this matter are presented below. 
% \textcolor{red}{TODO expand}

Balzuweit et. al. \cite{Bal13SnapViz} developed a prototype tool named \textbf{SnapViz} which aims to standardize the systems for displaying snapshot data gathered from programming students. The tool consumes timestamped data points containing information about a student, a task, the student's score achieved on the task with the relevant code snapshot, and a label (e.g. an error message). Thanks to the data, a plot is generated with time and date axes, that presents how individual's solutions evolved in time. This way it can be observed how many attempts a student took and if the score increased gradually or with a spike. The authors of the article hoped to spur discussion and they actually succeeded judging by references appearing in some of the papers mentioned below.

% \textcolor{red}{TODO rewrite}
Shrestha et. al. \cite{Shr22CodeProcess} presented a tool called \textbf{CodeProcess} for visualizing the programming process \ref{def:programming_process}. The main point of the tool is to show the order in which the source code was written. The tool allows to see the keystroke data in a plot arranged from each character added. 
% \textcolor{red}{TODO expand previous}
The authors conducted a study to evaluate the usefulness of the tool for educators. They came with multiple potential areas for the tool including grading assistance, determining student's approach to the problem (top-down or bottom-up), detecting plagiarism, or finding struggling students in need of support. Apart from teachers, students could use the tool to reflect on themselves to see different approaches in overcoming potential obstacles. The authors state that the process of analyzing the plots could be enhanced by ML to enable automated reasoning (e.g. for plagiarism screening). Apart from education, the ideas behind the tool are expected to be used in the professional context for code reviews and self-growth of programmers.

Matsuzawa et. al. \cite{Mat13PPV} developed a tool named \textbf{Programming Process Visualizer} (\textbf{PPV}) based on the Personal Software Process (PSP) framework. It comprises a set of techniques to help engineers and their organizations improve their performance through a disciplined approach to measuring and analyzing their work \cite{Hum96PSS}. The PPV software allows students to analyze their programming process after completing a programming task. The tool provided students with the replay ability, so they could see the animation of writing the source code. In parallel, the metrics are calculated, including number of lines, working time and other information about compilations and runs. A notable feature crucial for the PSP is the ability to provide labels for the subtasks, that is pieces of code, for what students actually attempted to achieve by writing them. This way students are able to estimate the time they thought it would take them to complete an assignment and compare it with the real time span. The researchers tested their tool empirically on the students and it gave them promising results with the students providing positive responses.

Biehl et. al. \cite{Bie07FASTDash} created a tool called \textbf{FASTDash} to enhance team awareness in software development projects. They intended to achieve that by deploying a visualization that provides information about current activities of each programmer. This way a developer can quickly learn which team members are working on each files or even exactly on which parts of code like classes or methods. The developers can even provide comments for better understanding. One of the more obvious advantages of this solution is to mitigate the risk of conflict situations. The tool was tested in an experimental environment with promising results and some developers continuing to use it afterwards.

Lyulina et. al. \cite{Lyu21TaskTracker} developed a toolkit named \textbf{TaskTracker} for collecting and analyzing data of student programming process. The gathered data includes code snapshots of high granularity (even with 1 character change) and other user actions taken within the IDE based on the IntelliJ Platform. The tool allows for tracking solving a fixed number of predefined tasks in various programming languages. The authors created and published a dataset by tracking activities of 148 participants. It is interesting to see that the tool can be used to detect plagiarism similarly to one of the tools above.

% \textcolor{red}{TODO! More!}
Norris et. al. \cite{Nor08ClockIt} introduced a tool called \textbf{ClockIt} for monitoring student programming practices. It logs opening and closing projects or packages, compilation and run events, as well as files deletions and changes. The gathered data is presented in summary visualizations of compilation statuses and invocation outcomes within chosen time periods. The tool provides also the activity graph with the total count of events in time and the project growth graph with the total number of lines of code and comment in subsequent days.

The tools listed above differ in the granularity of the data gathered and the scope of the code base analysed. Some of them work on the keystroke level while the other analyze git commits. There are those focusing only on one source code file and those analyzing the entire code repository. Instead of attempting to utilize one of the available technologies, I have decided to build my own tool with the chosen level of granularity and the scope of observed code files. Nevertheless, the papers above constitute a meaningful source of inspiration for my work.

% Currently
% our toolset monitors programs written using the BlueJ IDE,
% but a plug-in for Eclipse is expected by the time of con-
% ference presentation. Using the Data Visualizer or web in-
% terface, students and instructors can view collected data.
% Preliminary analysis of CS 1 data seems to provide some
% insight regarding student software development practices.

% TODO review

% ArAl