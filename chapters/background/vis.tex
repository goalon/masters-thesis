\section{Tools for visualizing the programming process}

Visualization of software is a vigorously studied area \cite{Mat16SoftwareVisualizationReview, Nov13SEV}. It concerns mainly representations of software structure, behavior and evolution \cite{DieSoftViz}. In my thesis I am mostly interested in the last point with emphasis on visualization of the programming process by analyzing keystrokes. The different takes on this matter are presented below.

Balzuweit et. al. \cite{Bal13SnapViz} developed a prototype tool named \textbf{SnapViz} which aims to standardize the systems for displaying snapshot data gathered from programming students. The tool consumes timestamped data points containing information about a student, a task, the student's score achieved on the task with the relevant code snapshot, and a label (e.g. an error message). Thanks to the data, a plot is generated with time and date axes, that presents how individual's solutions evolved in time. This way it can be observed how many attempts a student took and if the score increased gradually or with a spike. The authors of the article hoped to spur discussion and they actually succeeded judging by references appearing in some of the papers mentioned below.

Shrestha et. al. \cite{Shr22CodeProcess} presented a tool called \textbf{CodeProcess} for visualizing the programming process \ref{def:programming_process}. The main point of the tool is to show the order in which the source code was written. The tool allows to see the keystroke data in a plot arranged from each character added. The authors conducted a study to evaluate the usefulness of the tool for educators. They came with multiple potential areas for the tool including grading assistance, determining student's approach to the problem (top-down or bottom-up), detecting plagiarism, or finding struggling students in need of support. Apart from teachers, students could use the tool to reflect on themselves to see different approaches in overcoming potential obstacles. The authors state that the process of analyzing the plots could be enhanced by ML to enable automated reasoning (e.g. for plagiarism screening). Apart from education, the ideas behind the tool are expected to be used in the professional context for code reviews and self-growth of programmers.

Matsuzawa et. al. \cite{Mat13PPV} developed a tool named \textbf{Programming Process Visualizer} (\textbf{PPV}) based on the Personal Software Process (PSP) framework. It comprises a set of techniques to help engineers and their organizations improve their performance through a disciplined approach to measuring and analyzing their work \cite{Hum96PSS}. The PPV software allows students to analyze their programming process after completing a programming task. The tool provided students with the replay ability, so they could see the animation of writing the source code. In parallel, the metrics are calculated, including number of lines, working time and other information about compilations and runs. A notable feature crucial for the PSP is the ability to provide labels for the subtasks, that is pieces of code, for what students actually attempted to achieve by writing them. This way students are able to estimate the time they thought it would take them to complete an assignment and compare it with the real time span. The researchers tested their tool empirically on the students and it gave them promising results with the students providing positive responses.

Biehl et. al. \cite{Bie07FASTDash} created a tool called \textbf{FASTDash} to enhance team awareness in software development projects. They intended to achieve that by deploying a visualization that provides information about current activities of each programmer. This way a developer can quickly learn which team members are working on each files or even exactly on which parts of code like classes or methods. The developers can even provide comments for better understanding. One of the more obvious advantages of this solution is to mitigate the risk of conflict situations. The tool was tested in an experimental environment with promising results and some developers continuing to use it afterwards.

Lyulina et. al. \cite{Lyu21TaskTracker} developed a toolkit named \textbf{TaskTracker} for collecting and analyzing data of student programming process. The gathered data includes code snapshots of high granularity (even with 1 character change) and other user actions taken within the IDE based on the IntelliJ Platform. The tool allows for tracking solving a fixed number of predefined tasks in various programming languages. The authors created and published a dataset by tracking activities of 148 participants. It is interesting to see that the tool can be used to detect plagiarism similarly to one of the tools above.

Norris et. al. \cite{Nor08ClockIt} introduced a tool called \textbf{ClockIt} for monitoring student programming practices. It logs opening and closing projects or packages, compilation and run events, as well as files deletions and changes. The gathered data is presented in summary visualizations of compilation statuses and invocation outcomes within chosen time periods. The tool provides also the activity graph with the total count of events in time and the project growth graph with the total number of lines of code and comment in subsequent days.

Minelli et. al. \cite{Min13DFlow} presented \textbf{DFlow} for recording and analyzing programmer's interactions with the \href{https://pharo.org/}{Pharo} IDE. The vital point of DFlow is its rather unique (at least at the time of publishing) scheme of visualizing events such as navigation and edits with respect to program entities (classes, methods and attributes). It enabled graphing programmer's behavior when shifting focus to different parts of the code. In the next paper \cite{Min14DFlow2} Minelli et. al. expanded on this concept by focusing on developers' experiences with the UI of the Pharo IDE. They created more visualizations, mostly by mapping programmers' actions on a timeline. The intention of this study was to help developers optimize their experience with the IDE.

Di Rosa et. al. \cite{Rosa20Ferax} published a study concerning visualizing programmers interaction data inside and outside the
IDE. They achieved this by building the \textbf{Ferax} tool on top of the existing plugin for Visual Studio Code called \href{https://marketplace.visualstudio.com/items?itemName=codelounge.tako}{\textbf{Tako}} which records and analyzes activity within the IDE. Despite possessing many desired features, I am not using Tako for my study since its source code is not publicly shared (\href{https://github.com/si-codelounge/tako}{its GitHub repository} does not contain the actual code), so making any changes is constricted. In addition, the collected data is very fine-grained, thus the amount of data that would be generated could have been troublesome for storing on participants' computers and then transferring it to my cloud storage for further analysis (see \ref{def:granularity}). Returning to Ferax, it provides many visualizations related to programmers using various kinds of applications, i.e. how much time they spent in programming, browser or social network apps. This way researchers got insight into distraction and productivity levels of their test subjects.

The tools listed above differ in the granularity of the data gathered and the scope of the code base analysed. Some of them work on the keystroke level while the other analyze git commits. There are those focusing only on one source code file and those analyzing the entire code repository. Instead of attempting to utilize one of the available technologies, I have decided to build my own tool with the chosen level of granularity and the scope of observed code files. Nevertheless, the papers above constitute a meaningful source of inspiration for my work. I note here that Zhevaho \cite{Zhe21OverviewCol} prepared an overview of tools for collecting the programmers data with many of these tools containing a visualization component. I recommend this paper to anyone interested in discovering less known programming process visualizers.
